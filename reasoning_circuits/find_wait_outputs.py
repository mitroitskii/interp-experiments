# %%
import os
import re
import json

# %%


def find_wait_in_outputs(output_base_dir="outputs"):
    """
    Scans output files generated by generate_output.py to find occurrences
    of the word 'wait' and collects detailed information about each occurrence.

    Args:
        output_base_dir (str): The base directory containing prompt subdirectories.

    Returns:
        list: A list of dictionaries, where each dictionary contains details
              about an occurrence of 'wait'. Format:
              [{'prompt': prompt_dir, 'seed': seed, 'config': config_name, 'output': section_content}]
    """
    results_list = []
    wait_pattern = re.compile(r'\bwait\b', re.IGNORECASE)
    config_pattern = re.compile(r'^--- (.*?) ---$', re.MULTILINE)

    if not os.path.isdir(output_base_dir):
        print(f"Error: Output directory '{output_base_dir}' not found.")
        return results_list

    for prompt_dir in os.listdir(output_base_dir):
        prompt_path = os.path.join(output_base_dir, prompt_dir)
        if not os.path.isdir(prompt_path):
            continue

        print(f"Scanning directory: {prompt_path}")

        for filename in os.listdir(prompt_path):
            if filename.startswith("seed_") and filename.endswith("_results.txt"):
                match = re.search(r'seed_(\d+)_results\.txt', filename)
                if not match:
                    continue
                seed_number = int(match.group(1))
                filepath = os.path.join(prompt_path, filename)

                try:
                    with open(filepath, 'r') as f:
                        content = f.read()
                except Exception as e:
                    print(f"Error reading file {filepath}: {e}")
                    continue

                config_matches = list(config_pattern.finditer(content))

                for i, match in enumerate(config_matches):
                    config_name = match.group(1).strip()
                    start_index = match.end()
                    end_index = config_matches[i+1].start() if (
                        i + 1) < len(config_matches) else len(content)

                    section_content = content[start_index:end_index].strip()

                    if wait_pattern.search(section_content):
                        results_list.append({
                            'prompt': prompt_dir,
                            'seed': seed_number,
                            'config': config_name,
                            'output': section_content
                        })

    return results_list


def save_results_to_json(results_list, output_base_dir):
    """Saves the results list to a JSON file."""
    if not results_list:
        print("\nNo occurrences of 'wait' found. No JSON file saved.")
        return

    results_list.sort(key=lambda x: (x['prompt'], x['seed'], x['config']))

    json_file_path = os.path.join(output_base_dir, "wait_occurrences.json")
    try:
        with open(json_file_path, 'w') as f:
            json.dump(results_list, f, indent=2)
        print(f"JSON results saved to: {json_file_path}")
    except Exception as e:
        print(f"Error saving JSON file {json_file_path}: {e}")


# %%
if __name__ == "__main__":
    script_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(script_dir)
    output_directory = os.path.join(script_dir, 'outputs')

    if not os.path.isdir(output_directory):
        output_directory = os.path.join(
            parent_dir, 'reasoning_circuits/outputs')
        print(f"Adjusted output directory path to: {output_directory}")

    wait_occurrences_list = find_wait_in_outputs(output_directory)

    save_results_to_json(wait_occurrences_list, output_directory)

# %%
