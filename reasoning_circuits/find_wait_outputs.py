# %%
import os
import re
import json
from collections import defaultdict

# %%


def find_wait_in_outputs(output_base_dir="outputs"):
    """
    Scans output files generated by generate_output.py to find occurrences
    of the word 'wait' in different generation configurations.

    Args:
        output_base_dir (str): The base directory containing prompt subdirectories.

    Returns:
        dict: A nested dictionary storing the results.
              Format: {prompt_dir: {seed: [config_name]}}
    """
    results = defaultdict(lambda: defaultdict(list))
    wait_pattern = re.compile(r'\bwait\b', re.IGNORECASE)
    config_pattern = re.compile(r'^--- (.*?) ---$', re.MULTILINE)

    if not os.path.isdir(output_base_dir):
        print(f"Error: Output directory '{output_base_dir}' not found.")
        return results

    for prompt_dir in os.listdir(output_base_dir):
        prompt_path = os.path.join(output_base_dir, prompt_dir)
        if not os.path.isdir(prompt_path):
            continue

        print(f"Scanning directory: {prompt_path}")  # Added print statement

        for filename in os.listdir(prompt_path):
            if filename.startswith("seed_") and filename.endswith("_results.txt"):
                match = re.search(r'seed_(\d+)_results\.txt', filename)
                if not match:
                    continue
                seed = f"seed_{match.group(1)}"
                filepath = os.path.join(prompt_path, filename)

                try:
                    with open(filepath, 'r') as f:
                        content = f.read()
                except Exception as e:
                    print(f"Error reading file {filepath}: {e}")
                    continue

                # Split content by configuration sections
                # Find all config headers first
                config_matches = list(config_pattern.finditer(content))

                for i, match in enumerate(config_matches):
                    config_name = match.group(1).strip()
                    start_index = match.end()
                    # Determine end index for the current section's content
                    end_index = config_matches[i+1].start() if (
                        i + 1) < len(config_matches) else len(content)

                    section_content = content[start_index:end_index].strip()

                    # Check for 'wait' within this section's content
                    if wait_pattern.search(section_content):
                        results[prompt_dir][seed].append(config_name)

    return results


def print_results(results):
    """Prints the found results in the specified nested format."""
    if not results:
        print("\nNo occurrences of 'wait' found in any generation.")
        return

    print("\nOccurrences of 'wait' found:")
    print("-" * 30)
    for prompt_dir, seeds in sorted(results.items()):
        print(prompt_dir)
        for seed, configs in sorted(seeds.items(), key=lambda item: int(item[0].split('_')[1])):
            print(f"- {seed}")
            for config in sorted(configs):
                print(f"-- {config}")
        print("-" * 30)  # Separator between prompts


def save_results_to_file(results, output_base_dir):
    """Saves the results to a file in the output directory."""
    # Convert defaultdict to regular dict for JSON serialization
    results_dict = {k: {s: list(c) for s, c in v.items()}
                    for k, v in results.items()}

    # Create a text version in the requested format
    text_output = ""
    if not results:
        text_output = "No occurrences of 'wait' found in any generation."
    else:
        text_output = "Occurrences of 'wait' found:\n"
        text_output += "-" * 30 + "\n"
        for prompt_dir, seeds in sorted(results_dict.items()):
            text_output += f"{prompt_dir}\n"
            for seed, configs in sorted(seeds.items(), key=lambda item: int(item[0].split('_')[1])):
                text_output += f"- {seed}\n"
                for config in sorted(configs):
                    text_output += f"-- {config}\n"
            text_output += "-" * 30 + "\n"

    # Save JSON version
    json_file_path = os.path.join(output_base_dir, "wait_occurrences.json")
    with open(json_file_path, 'w') as f:
        json.dump(results_dict, f, indent=2)
    print(f"JSON results saved to: {json_file_path}")

    # Save text version
    txt_file_path = os.path.join(output_base_dir, "wait_occurrences.txt")
    with open(txt_file_path, 'w') as f:
        f.write(text_output)
    print(f"Text results saved to: {txt_file_path}")


# %%
if __name__ == "__main__":
    # Assuming 'outputs' directory is in the same parent directory as the script
    script_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(script_dir)
    output_directory = os.path.join(parent_dir, 'reasoning_circuits/outputs')

    wait_occurrences = find_wait_in_outputs(output_directory)
    print_results(wait_occurrences)

    # Save results to disk
    save_results_to_file(wait_occurrences, output_directory)

# %%
